### YamlMime:QSharpType
uid: microsoft.quantum.canon.ampampbyoracle
name: AmpAmpByOracle
type: function
namespace: Microsoft.Quantum.Canon
summary: Standard Amplitude Amplification algorithm
remarks: >-
  This is the standard amplitude amplification algorithm obtained by a choice of reflection phases computed by `AmpAmpPhasesStandard`
  Assuming that
  \begin{align}
  A\ket{0}\_{f}\ket{0}\_s= \lambda\ket{1}\_f\ket{\text{target}}\_s + \sqrt{1-|\lambda|^2}\ket{0}\_f\cdots,
  \end{align}
  this operation prepares the state
  \begin{align}
  \operatorname{AmpAmpByOracle}\ket{0}\_{f}\ket{0}\_s= \sin((2n+1)\sin^{-1}(\lambda))\ket{1}\_f\ket{\text{target}}\_s + \cdots\ket{0}\_f
  \end{align}
  In most cases, `flagQubit` and `ancillaRegister` is initialized in the state $\ket{0}\_f\ket{0}\_a$.
syntax: 'function AmpAmpByOracle (nIterations : Int, stateOracle : Microsoft.Quantum.Canon.StateOracle, idxFlagQubit : Int) : (Qubit[] => Unit : Adjoint, Controlled)'
references: '- [ *G. Brassard, P. Hoyer, M. Mosca, A. Tapp* ](https://arxiv.org/abs/quant-ph/0005055)'
input:
  content: '(nIterations : Int, stateOracle : Microsoft.Quantum.Canon.StateOracle, idxFlagQubit : Int)'
  types:
  - name: nIterations
    summary: Number of iterations $n$ of amplitude amplification
    isPrimitive: true
    uid: Int
  - name: stateOracle
    uid: microsoft.quantum.canon.stateoracle
  - name: idxFlagQubit
    summary: Index to flag qubit
    isPrimitive: true
    uid: Int
output:
  content: '(Qubit[] => Unit : Adjoint, Controlled)'
  types:
  - summary: An operation that implements the standard amplitude amplification quantum algorithm
    isOperation: true
    input:
      types:
      - isArray: true
        isPrimitive: true
        uid: Qubit
    output:
      types:
      - isPrimitive: true
        uid: Unit
    functors:
    - Adjoint
    - Controlled
...
