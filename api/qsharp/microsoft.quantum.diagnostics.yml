### YamlMime:QSharpNamespace
# This file is automatically generated.
# Please do not modify this file manually, or your changes may be lost when
# documentation is rebuilt.
functions:
- {summary: Asserts that two arrays of boolean values are equal., uid: Microsoft.Quantum.Diagnostics.AllEqualityFactB}
- {summary: Asserts that two arrays of integer values are equal., uid: Microsoft.Quantum.Diagnostics.AllEqualityFactI}
- {summary: Declares that a classical condition is false., uid: Microsoft.Quantum.Diagnostics.Contradiction}
- {summary: Dumps the current target machine's status., uid: Microsoft.Quantum.Diagnostics.DumpMachine}
- {summary: Dumps the current target machine's status associated with the given qubits.,
  uid: Microsoft.Quantum.Diagnostics.DumpRegister}
- {summary: Asserts that a classical Bool variable has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactB}
- {summary: Asserts that a complex number has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactC}
- {summary: Asserts that a complex number has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactCP}
- {summary: Asserts that a classical Int variable has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactI}
- {summary: Asserts that a classical BigInt variable has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactL}
- {summary: Asserts that a classical Result variable has the expected value., uid: Microsoft.Quantum.Diagnostics.EqualityFactR}
- {summary: Represents the claim that a classical floating point value has the expected
    value up to a given absolute tolerance., uid: Microsoft.Quantum.Diagnostics.EqualityWithinToleranceFact}
- {summary: Declares that a classical condition is true., uid: Microsoft.Quantum.Diagnostics.Fact}
- {summary: Internal function used to fail with meaningful error messages., uid: Microsoft.Quantum.Diagnostics.FormattedFailure}
- {summary: Asserts that a classical complex number has the expected value up to a
    small tolerance of 1e-10., uid: Microsoft.Quantum.Diagnostics.NearEqualityFactC}
- {summary: Asserts that a classical complex number has the expected value up to a
    small tolerance of 1e-10., uid: Microsoft.Quantum.Diagnostics.NearEqualityFactCP}
- {summary: Asserts that a classical floating point value has the expected value up
    to a small tolerance of 1e-10., uid: Microsoft.Quantum.Diagnostics.NearEqualityFactD}
name: Microsoft.Quantum.Diagnostics
newtypes:
- {summary: Compiler-recognized attribute via which an alternative name can be defined
    that may be used when loading a type or callable for testing purposes., uid: Microsoft.Quantum.Diagnostics.EnableTestingViaName}
- {summary: Compiler-recognized attribute used to mark a unit test., uid: Microsoft.Quantum.Diagnostics.Test}
operations:
- {summary: 'Between a call to this operation and its adjoint, asserts that a given
    operation is called at most a certain number of times.', uid: Microsoft.Quantum.Diagnostics.AllowAtMostNCallsCA}
- {summary: 'Between a call to this operation and its adjoint, asserts that at most
    a given number of additional qubits are allocated with using statements.', uid: Microsoft.Quantum.Diagnostics.AllowAtMostNQubits}
- {summary: 'Assert that given qubits are all in $\ket{0}$ state.', uid: Microsoft.Quantum.Diagnostics.AssertAllZero}
- {summary: 'Assert that given qubits are all in $\ket{0}$ state up to a given tolerance.',
  uid: Microsoft.Quantum.Diagnostics.AssertAllZeroWithinTolerance}
- {summary: Asserts that measuring the given qubits in the given Pauli basis will
    always have the given result., uid: Microsoft.Quantum.Diagnostics.AssertMeasurement}
- {summary: 'Asserts that measuring the given qubits in the given Pauli basis will
    have the given result with the given probability, within some tolerance.', uid: Microsoft.Quantum.Diagnostics.AssertMeasurementProbability}
- {summary: "Given two operations, asserts that they act identically for all input\
    \ states.\nThis assertion is implemented by checking the action of the operations\
    \ on all states of the form $V_0 \\otimes ... \\otimes V_{n-1}$, where $V_k$ is\
    \ one of the states $\\ket{0}$, $\\ket{1}$, $\\ket{+}$ and $\\ket{i}$ (+1 eigenstate\
    \ of Pauli Y operator).\nThis assertion uses $n$ qubits and requires multiple\
    \ calls of the operations being compared.", uid: Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlace}
- {summary: 'Checks if the operation `givenU` is equal to the operation `expectedU`
    on the given input size  by checking the action of the operations only on the
    vectors from the computational basis. This is a necessary, but not sufficient,
    condition for the equality of two unitaries.', uid: Microsoft.Quantum.Diagnostics.AssertOperationsEqualInPlaceCompBasis}
- {summary: "Given two operations, asserts that they act identically for all input\
    \ states.\nThis assertion is implemented by using the Choi\u2013Jamio\u0142kowski\
    \ isomorphism to reduce the assertion to one of a qubit state assertion on two\
    \ entangled registers. Thus, this operation needs only a single call to each operation\
    \ being tested, but requires twice as many qubits to be allocated. This assertion\
    \ can be used to ensure, for instance, that an optimized version of an operation\
    \ acts identically to its na\xEFve implementation, or that an operation which\
    \ acts on a range of non-quantum inputs agrees with known cases.", uid: Microsoft.Quantum.Diagnostics.AssertOperationsEqualReferenced}
- {summary: Asserts that the phase of an equal superposition state has the expected
    value., uid: Microsoft.Quantum.Diagnostics.AssertPhase}
- {summary: Asserts that the qubit `q` is in the expected eigenstate of the Pauli
    Z operator., uid: Microsoft.Quantum.Diagnostics.AssertQubit}
- {summary: "Asserts that a qubit in the expected state.\n`expected` represents a\
    \ complex vector, $\\ket{\\psi} = \\begin{bmatrix}a & b\\end{bmatrix}^{\\mathrm{T}}$.\
    \ The first element of the tuples representing each of $a$, $b$ is the real part\
    \ of the complex number, while the second one is the imaginary part. The last\
    \ argument defines the tolerance with which assertion is made.", uid: Microsoft.Quantum.Diagnostics.AssertQubitIsInStateWithinTolerance}
- {summary: Asserts that the qubit `q` is in the expected eigenstate of the Pauli
    Z operator up to a given tolerance., uid: Microsoft.Quantum.Diagnostics.AssertQubitWithinTolerance}
- {summary: 'Given an operation, displays diagnostics about the operation that are
    made available by the current execution target.', uid: Microsoft.Quantum.Diagnostics.DumpOperation}
- {summary: 'Uses DumpRegister to provide diagnostics on the state of a reference
    and target register. Written as separate operation to allow overriding and interpreting
    as separate registers, rather than as a single combined register.', uid: Microsoft.Quantum.Diagnostics.DumpReferenceAndTarget}
- {summary: Checks if the result of applying two operations `givenU` and `expectedU`
    to a basis state is the same. The basis state is described by `basis` parameter.
    See <xref:microsoft.quantum.extensions.fliptobasis> function for more details
    on this description., uid: Microsoft.Quantum.Diagnostics._assertEqualOnBasisVector}
- {summary: "Applies unitaries that map $\\ket{0}\\otimes\\cdots\\ket{0}$ to $\\ket{\\\
    psi_0} \\otimes \\ket{\\psi_{n - 1}}$, where $\\ket{\\psi_k}$ depends on `basis[k]`.\n\
    The correspondence between value of `basis[k]` and $\\ket{\\psi_k}$ is the following:\n\
    - `basis[k]=0` $\\rightarrow \\ket{0}$. - `basis[k]=1` $\\rightarrow \\ket{1}$.\
    \ - `basis[k]=2` $\\rightarrow \\ket{+}$. - `basis[k]=3` $\\rightarrow \\ket{i}$\
    \ ( +1 eigenstate of Pauli Y ).", uid: Microsoft.Quantum.Diagnostics._flipToBasis}
- {summary: "Iterates a variable through a Cartesian product [ 0, bounds[0]-1 ] \xD7\
    \ [ 0, bounds[1]-1 ] \xD7 [ 0, bounds[Length(bounds)-1]-1 ] and calls op(arr)\
    \ for every element of the Cartesian product", uid: Microsoft.Quantum.Diagnostics._iterateThroughCartesianPower}
- {summary: "Given two registers, prepares the maximally entangled state between each\
    \ pair of qubits on the respective registers. All qubits must start in the |0\u27E9\
    \ state.\nThe result is that corresponding pairs of qubits from each register\
    \ are in the $\\bra{\\beta_{00}}\\ket{\\beta_{00}}$.", uid: Microsoft.Quantum.Diagnostics._prepareEntangledState}
summary: ''
uid: Microsoft.Quantum.Diagnostics
