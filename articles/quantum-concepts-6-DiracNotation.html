<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="QuantumWriter">
  <meta name="keywords" content="Don’t add or edit keywords without consulting your SEO champ.">
  <title>Intent and product brand in a unique string of 43-59 chars including spaces | Microsoft Docs</title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Intent and product brand in a unique string of 43-59 chars including spaces | Microsoft Docs</h1>
<p class="author">QuantumWriter</p>
</header>
<h1 id="dirac-notation">Dirac notation</h1>
<p>While column vector notation is ubiquitous in linear algebra, it is often cumbersome in quantum computing especially when dealing with multiple qubits. The two main reasons for this are that when we define <span class="math inline">\(\psi\)</span> to be a vector it is not explicitly clear whether <span class="math inline">\(\psi\)</span> is a row or a column vector. Thus if <span class="math inline">\(\phi\)</span> and <span class="math inline">\(\psi\)</span> are vectors then it is not clear whether <span class="math inline">\(\phi \psi\)</span> is defined because the shapes of <span class="math inline">\(\phi\)</span> and <span class="math inline">\(\psi\)</span> may be unclear in the context. Apart from ambiguity about the shapes of vectors expressing even expressing simple vectors using the linear algebraic notation introduced earlier can be very cumbersome. For example, if we wish to describe an <span class="math inline">\(n\)</span>-qubit state where each qubit takes the value <span class="math inline">\(0\)</span> then we would formally express the state as <span class="math display">\[\begin{bmatrix}1 \\ 0 \end{bmatrix}\otimes \cdots \otimes\begin{bmatrix}1 \\ 0 \end{bmatrix}. \]</span> Of course evaluating this tensor product is impractical because the vector lies in an exponentially large space and so this notation is in fact the best description of the state that can be given using the previous notation. Dirac notation solves these issues by developing a new language to fit the precise needs of quantum mechanics. For this reason, we recommend not looking at any of these examples in this section as a rigid prescription of how to describe quantum states but rather encourage the reader to view these as suggestions that can be used to concisely express quantum ideas.</p>
<p>There are two types of vectors in Dirac notation: the bra-vector and the ket-vector, so named because when put together they form a braket or inner product. If <span class="math inline">\(\psi\)</span> is a column vector then we can write it in Dirac notation as <span class="math inline">\(|\psi \rangle\)</span>, where the <span class="math inline">\(|\cdot \rangle\)</span> denotes that it is a unit-column vector i.e. a ``ket&quot; vector. Similarly, the row vector <span class="math inline">\(\psi^\dagger\)</span> is expressed as <span class="math inline">\(\langle \psi |\)</span>. This notation directly implies that <span class="math inline">\(\langle \psi |\psi \rangle\)</span> is the inner product of vector <span class="math inline">\(\psi\)</span> with itself which is by definition <span class="math inline">\(1\)</span>. More generally, if <span class="math inline">\(\psi\)</span> and <span class="math inline">\(\phi\)</span> are quantum state vectors their inner product is <span class="math inline">\(\langle \phi | \psi \rangle\)</span> which implies that the probability of measuring the state <span class="math inline">\(|{\psi}\rangle\)</span> to be <span class="math inline">\(|{\phi}\rangle\)</span> is <span class="math inline">\(|\langle \phi|\psi\rangle|^2\)</span>.</p>
<p>As an example, consider the braket <span class="math inline">\(\langle 0 | 1\rangle\)</span> which is the inner product between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>. This can be written as <span class="math display">\[\langle 0| 1 \rangle=\begin{bmatrix} 1 &amp; 0 \end{bmatrix}\begin{bmatrix}0\\1\end{bmatrix}=0.\]</span> It is then easy to see that both states are orthogonal vectors, meaning that <span class="math inline">\(\langle 0 |1\rangle = \langle 1 | 0\rangle =0\)</span>. Also by definition <span class="math inline">\(\langle 0 | 0 \rangle = \langle 1 | 1\rangle=1\)</span>, which means that the two computational basis vectors can also be called orthonormal. These orthonormality properties will be useful in the following example. If we have a state <span class="math inline">\(|\psi\rangle = {\frac{3}{5}} |1\rangle + {\frac{4}{5}} |0\rangle\)</span> then because $ 1 | 0=0$ the probability of measuring <span class="math inline">\(1\)</span> is <span class="math display">\[\big|\langle 1 | \psi\rangle \big|^2= \left|\frac{3}{5}\langle 1 | 1\rangle +\frac{4}{5}\langle 1 |0 \rangle\right|^2=\frac{9}{25}.\]</span></p>
<p>The following convention is used to describe the quantum states that encode values of zero and one (the single-qubit computational basis states) <span class="math display">\[
\begin{bmatrix} 1 \\ 0 \end{bmatrix} = |0\rangle,\qquad
\begin{bmatrix} 0 \\ 1 \end{bmatrix} = |1\rangle,
\]</span> and the following notation is often used to describe the states that result from applying the Hadamard gate to <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span> (which correspond to the unit vectors in the +x and -x directions on the Bloch sphere) <span class="math display">\[
\frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ 1 \end{bmatrix}=H|0\rangle = |{+}\rangle,\qquad
\frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ -1 \end{bmatrix} =H|1\rangle = |{-}\rangle .
\]</span> These states can also be expanded using Dirac notation as sums of <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span>: <span class="math display">\[
|+\rangle = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle),\qquad |-\rangle = \frac{1}{\sqrt{2}}(|0\rangle - |1\rangle).
\]</span> This demonstrates why these states are often called a computational basis: every quantum state can always be expressed as sums of computational basis vectors and such sums are easily expressed using Dirac notation. The converse is also true in that the states <span class="math inline">\(|+\rangle\)</span> and <span class="math inline">\(|-\rangle\)</span> also form a basis for quantum states. You can see this from the fact that <span class="math display">\[
|0\rangle = \frac{1}{\sqrt{2}}(|+\rangle + |-\rangle),\qquad |1\rangle = \frac{1}{\sqrt{2}}(|+\rangle - |-\rangle).
\]</span></p>
<p>Dirac notation also includes an implicit tensor product structure within it. This is important because in quantum computing, the state vector described by two uncorollated quantum registers is the tensor products of the two state vectors. Concisely describing the tensor product structure, or lack thereof, is therefore vital if you want to explain a quantum computation. This tensor product structure implies that we can write <span class="math inline">\(\psi \otimes \phi\)</span> for any two quantum state vectors <span class="math inline">\(\phi\)</span> and <span class="math inline">\(\psi\)</span> as <span class="math inline">\(|\psi\rangle |\phi\rangle\)</span> which is sometimes explicitly written as <span class="math inline">\(|\psi\rangle \otimes |\phi\rangle\)</span> but by convention writing <span class="math inline">\(\otimes\)</span> in between the vectors is unnecessary. For example, the state with two qubits initialized to the zero state would be <span class="math display">\[
\begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}= \begin{bmatrix} 1 \\ 0 \end{bmatrix} \otimes \begin{bmatrix} 1 \\ 0 \end{bmatrix} = |0\rangle \otimes |0\rangle= |0\rangle |0\rangle.
\]</span> Similarly, the state <span class="math inline">\(|{p}\rangle\)</span> for integer <span class="math inline">\(p\)</span> represents a quantum state that encodes in a binary representation the integer <span class="math inline">\(p\)</span>. For example, if we wished to express the number <span class="math inline">\(3\)</span> using an unsigned binary encoding we could equally express it as <span class="math display">\[
|{1}\rangle|{0}\rangle|{1}\rangle = |{101}\rangle = |{3}\rangle.
\]</span> Within this notation <span class="math inline">\(|{0}\rangle\)</span> need not refer to a single qubit state but rather a qubit register storing a binary encoding of <span class="math inline">\(0\)</span>. The differences between these two notations can is usually clear within the context it is used. This convention is useful for simplifying the first example which can be written in any of the following ways <span class="math display">\[
\begin{bmatrix}1 \\ 0 \end{bmatrix}\otimes \cdots \otimes\begin{bmatrix}1 \\ 0 \end{bmatrix} = |0\rangle \otimes \cdots \otimes |0\rangle= |0\cdots 0\rangle = |0\rangle^{\otimes n} = |0\rangle.
\]</span> As another example of how you can use Dirac notation to describe a quantum state, consider the following equivalent ways of writing a quantum state that is an equal superposition over every possible bit string of length <span class="math inline">\(n\)</span> <span class="math display">\[
H^{\otimes n} |{0}\rangle = \frac{1}{2^{n/2}} \sum_{j=0}^{2^n-1} |{j}\rangle=|+\rangle^{\otimes n}.
\]</span> Here you may wonder why the sum goes from <span class="math inline">\(0\)</span> to <span class="math inline">\(2^{n}-1\)</span> for <span class="math inline">\(n\)</span> bits. First note that there are <span class="math inline">\(2^{n}\)</span> different configurations that <span class="math inline">\(n\)</span> bits can take. You can see this by noting that one bit can take <span class="math inline">\(2\)</span> values but two bits can take <span class="math inline">\(4\)</span> values and so forth. In general, this means that there are <span class="math inline">\(2^n\)</span> different possible bit strings but the largest value encoded in any of them <span class="math inline">\(1\cdots 1=2^n-1\)</span> and hence it is the upper limit for the sum. As a side note, in this example we did not use <span class="math inline">\(|+\rangle^{\otimes n}=|+\rangle\)</span> in analogy to <span class="math inline">\(|0\rangle^{\otimes n} = |0\rangle\)</span> because this notational convention is usually reserved for the computational basis state that has every qubit initialized to zero. While such a convention would be sensible in this case, it is not employed in the quantum computing literature.</p>
<p>Another nice feature of Dirac notation is the fact that it is linear. If we wished to write for any four quantum state vectors, <span class="math display">\[(\alpha |\psi\rangle +\beta|\phi\rangle)\otimes (\gamma |\chi\rangle + \delta |\omega\rangle)= \alpha\gamma |\psi\rangle|\chi\rangle + \alpha\delta |\psi\rangle|\omega\rangle+\beta\gamma|\phi\rangle|\chi\rangle+\beta\omega|\phi\rangle|\omega\rangle.\]</span> That is to say, you can distribute the tensor product notation in Dirac notation so that taking tensor products between state vectors ends up looking just like ordinary multiplication.</p>
<p>Bra vectors follow a similar convention to ket vectors. For example the vector <span class="math inline">\(\langle\psi|\langle \phi|\)</span> is equivalent to the state vector <span class="math inline">\(\psi^\dagger \otimes \phi^\dagger=(\psi\otimes \phi)^\dagger\)</span>. For example if the ket vector <span class="math inline">\(|\psi\rangle\)</span> is <span class="math inline">\(\alpha |0\rangle + \beta |1\rangle\)</span> then the bra vector version of the vector is <span class="math inline">\(\langle{\psi}|=|\psi\rangle^\dagger = (\langle 0|\alpha^* +\langle 1 |\beta^*)\)</span>. This As an example, imagine that we wished to calculate the probability of measuring the state <span class="math inline">\(|\psi\rangle = \frac{3}{5} |1\rangle + \frac{4}{5} |0\rangle\)</span> using a quantum program for measuring states to be either <span class="math inline">\(|+\rangle\)</span> or <span class="math inline">\(|-\rangle\)</span> then the probability that the device would output that the state is <span class="math inline">\(|-\rangle\)</span> is <span class="math display">\[|\langle - |\psi\rangle|^2= \left|\frac{1}{\sqrt{2}}(\langle 0| - \langle 1|)(\frac{3}{5} |1\rangle + \frac{4}{5} |0\rangle) \right|^2=\left|-\frac{3}{5\sqrt{2}} + \frac{4}{5\sqrt{2}}\right|^2=\frac{1}{50}.\]</span> The fact that the negative sign appears in the calculation of the probability is a manifestation of quantum interference, which is one of the mechanisms by which quantum computing gains advantages over classical computing.</p>
<p>The final object that is worth discussing in Dirac notation is the outer product or ketbra. Such terms are represented within Dirac notations as <span class="math inline">\(|\psi\rangle \langle \phi|\)</span>, and are called ketbras because the bras and kets occur in the opposite order as brakets. The outer product is defined via matrix multiplication as <span class="math inline">\(|\psi\rangle \langle \phi| = \psi \phi^\dagger\)</span> for quantum state vectors <span class="math inline">\(\psi\)</span> and <span class="math inline">\(\phi\)</span>. The simplest, and arguably most common example of this notation is <span class="math display">\[
|0\rangle \langle 0| = \begin{bmatrix}1\\0 \end{bmatrix}\begin{bmatrix}1&amp;0 \end{bmatrix}= \begin{bmatrix}1 &amp;0\\0 &amp;0\end{bmatrix} \qquad |1\rangle \langle 1| = \begin{bmatrix}0\\1 \end{bmatrix}\begin{bmatrix}0&amp;1 \end{bmatrix}= \begin{bmatrix}0 &amp;0\\0 &amp;1\end{bmatrix}.
  \]</span> These ketbras are often called projectors because they project a quantum state onto a fixed value. Since these operations are not unitary (and do not even preserve the norm of a vector), it should come as no surprise that a quantum computer cannot deterministically apply a projector. However projectors do a beautiful job of describing the action that measurement has on a quantum state. For example, if we measure a state <span class="math inline">\(|\psi \rangle\)</span> to be <span class="math inline">\(0\)</span> then the resulting transformation that the state experiences as a result of the measurement is <span class="math display">\[|\psi \rangle \rightarrow \frac{(|0\rangle \langle 0|)|\psi\rangle}{\langle 0|\psi\rangle}= |0\rangle,\]</span> as one expects if you were to measure the state in <span class="math inline">\(0\)</span>. The probability of such a measurement succeeding can be written as the expectation value of the quantum projector in the state <span class="math display">\[
\langle \psi| (|0\rangle \langle 0|)|\psi\rangle = |\langle \psi|0\rangle|^2
  \]</span></p>
<p>A final point that is worth raising about quantum notation. While at the onset of this document we mentioned that the quantum state is the fundamental object of quantum computing. It may then come as a surprise that in Q# there is no notion of a quantum state. Instead, all states are described only by the circuit used to prepare them. The previous example is an excellent illustration of this. Rather than expressing a uniform superposition over every quantum bit string in a register, we can represent the result as <span class="math inline">\(H^{\otimes n} |{0}\rangle\)</span>. This exponentially shorter description of the state not only has the advantage that we can classically reason about it but it also because it concisely gives the operations needed to be propagated through the software stack to implement the algorithm. For this reason, Q# is designed to emit gate sequences rather than quantum states; however, at a theoretical level the two perspectives are equivalent.</p>
</body>
</html>
